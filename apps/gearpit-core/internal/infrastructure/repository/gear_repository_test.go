//go:build integration

package repository_test

import (
	"context"
	"fmt"
	"os"
	"testing"
	"time"

	"github.com/nordiwnd/gearpit/apps/gearpit-core/internal/domain"
	"github.com/nordiwnd/gearpit/apps/gearpit-core/internal/infrastructure/repository"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

// Helper to get env param or default
func getEnv(key, fallback string) string {
	if value, ok := os.LookupEnv(key); ok {
		return value
	}
	return fallback
}

// Setup DB connection
func newTestDB(t *testing.T) *gorm.DB {
	dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=disable TimeZone=Asia/Tokyo",
		getEnv("DB_HOST", "localhost"),
		getEnv("DB_USER", "gearpit"),
		getEnv("DB_PASSWORD", "password"),
		getEnv("DB_NAME", "gearpit"),
		getEnv("DB_PORT", "5432"),
	)
	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
	require.NoError(t, err)

	// Since we are outside the package, we need to ensure tables exist
	// In a real scenario we might use migrations, but Automigrate is fine for tests
	err = db.AutoMigrate(
		&domain.Item{},
		&domain.Kit{},
		&domain.Loadout{},
		&domain.MaintenanceLog{},
		&domain.UserProfile{},
		&domain.Trip{},
		&domain.TripItem{},
	)
	require.NoError(t, err)

	return db
}

func TestGearRepository_Integration(t *testing.T) {
	db := newTestDB(t)
	repo := repository.NewGearRepository(db)
	ctx := context.Background()

	// 1. Create
	// Item struct has strict validation on some fields if tags are present,
	// but mostly it relies on GORM to handle UUID generation.
	item := &domain.Item{
		Name:         "Integration Test Gear",
		Description:  "Created during integration test",
		WeightGram:   500,
		WeightType:   domain.WeightTypeBase,
		Manufacturer: "TestMfg",
		CreatedAt:    time.Now(),
		UpdatedAt:    time.Now(),
	}

	err := repo.Create(ctx, item)
	require.NoError(t, err)
	assert.NotEmpty(t, item.ID, "ID should be generated by DB")

	// 2. GetByID
	fetched, err := repo.GetByID(ctx, item.ID)
	require.NoError(t, err)
	assert.Equal(t, item.Name, fetched.Name)
	assert.Equal(t, item.WeightGram, fetched.WeightGram)

	// 3. Update
	fetched.WeightGram = 600
	fetched.Manufacturer = "UpdatedMfg"
	err = repo.Update(ctx, fetched)
	require.NoError(t, err)

	fetchedUpdated, err := repo.GetByID(ctx, item.ID)
	require.NoError(t, err)
	assert.Equal(t, 600, fetchedUpdated.WeightGram)
	assert.Equal(t, "UpdatedMfg", fetchedUpdated.Manufacturer)

	// 4. List
	items, err := repo.List(ctx)
	require.NoError(t, err)
	assert.NotEmpty(t, items)
	// Check if our item is in the list
	found := false
	for _, i := range items {
		if i.ID == item.ID {
			found = true
			break
		}
	}
	assert.True(t, found, "Created item should be in the list")

	// 5. Delete
	err = repo.Delete(ctx, item.ID)
	require.NoError(t, err)

	// Verify deletion
	_, err = repo.GetByID(ctx, item.ID)
	assert.Error(t, err) // Should error (record not found)
}
